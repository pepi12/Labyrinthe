{"version":3,"sources":["component/AffichageGraph.js","index.js"],"names":["murPourFinirLabyrinthe","AffichageGraph","props","tableauNodes","cmpty","cmptx","compteur","labyrintheWidth","Math","floor","random","labyrintheHeight","nbNodes","i","push","id","color","groupe","x","y","creerMurs","forEach","node","state","nodes","edges","width","height","tabIdNodesTemp","cheminTemp","round","length","this","creerMursGaucheDroite","depart","maxmin","maxminHautbas","creerMursHautBas","maxminGaucheDroite","tabIdNodesPlus","tabIdNodesMoins","retour","graph","options","layout","hierarchical","shape","size","interaction","dragNodes","zoomView","physics","enabled","arrows","to","style","React","Component","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.bdc81c22.chunk.js","sourcesContent":["import React from 'react';\r\nimport Graph from \"react-graph-vis\";\r\n\r\n//Sert à s'assurer que le labyrinthe soit finissable\r\nvar murPourFinirLabyrinthe = 0;\r\n\r\n/*\r\n    Auteur : Bastien Boulanger\r\n    DA : 1838295\r\n    Nom : AffichageGraph\r\n    Description : S'occupe de l'affichage du labyrinthe. La case bleu est le départ, et la case rouge est la fin. Cette fonction\r\n                  appelle aussi la methode qui démare la création des murs.\r\n*/\r\nclass AffichageGraph extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n        //Instancie les variables\r\n        var tableauNodes = [];\r\n        var tableauEdges = [];\r\n        var cmpty = 0;\r\n        var cmptx = 0;\r\n        var compteur = 1;\r\n\r\n        //Ici on indique la taille du labyrinthe. Le chiffre apres le * est la variation que notre chiffre pourrais avoir dans les positifs\r\n        // et le chiffre apres le + indique la plus petite valeur. La largeur du labyrithe est alératoire, mais la hauteur seras toujours\r\n        // 4 de plus que la largeur.\r\n        var labyrintheWidth = Math.floor(Math.random() * 6) + 40;\r\n        while (labyrintheWidth === 42 || labyrintheWidth === 41) {\r\n            labyrintheWidth = Math.floor(Math.random() * 6) + 40;\r\n        }\r\n        var labyrintheHeight = labyrintheWidth;\r\n        //Ici on instancie le nombre maximum de node\r\n        var nbNodes = labyrintheWidth * labyrintheHeight;\r\n\r\n        //Cette section sert a inserer les nodes dans le tableau tableauNodes en leur associant une couleur et une position.\r\n        for (var i = 0; i < nbNodes; i++) {\r\n\r\n            //Indique le debut du labyrinthe\r\n            if (i === 0) {\r\n                tableauNodes.push({ id: i, color: \"#6DB1E5\", groupe: \"Chemin\", x: cmptx, y: cmpty });\r\n            }\r\n\r\n            //Indique la fin du labyrinthe\r\n            else if (i === nbNodes - 1) {\r\n                tableauNodes.push({ id: i, color: \"#D83D3D\", groupe: \"Chemin\", x: cmptx, y: cmpty });\r\n            }\r\n\r\n            //Indique les chemins du labyrinthe\r\n            else {\r\n                tableauNodes.push({ id: i, color: \"#D5C586\", groupe: \"Chemin\", x: cmptx, y: cmpty });\r\n            }\r\n\r\n            //Gestion de position pour affichage\r\n            cmptx += 100;\r\n            if (i === (labyrintheWidth * compteur) - 1) {\r\n                cmpty += 100;\r\n                cmptx = 0;\r\n                compteur++;\r\n            }\r\n\r\n        }\r\n\r\n        //Appele la fonction pour créer les murs du labyrinthe\r\n        this.creerMurs(labyrintheWidth, labyrintheHeight, tableauNodes);\r\n\r\n        //s'assure que le labyrinthe soit finissable\r\n        tableauNodes.forEach(node => {\r\n            if (node.id === murPourFinirLabyrinthe - 1 || node.id === murPourFinirLabyrinthe || node.id === murPourFinirLabyrinthe + 1) {\r\n                node.color = \"#D5C586\";\r\n            }\r\n        });\r\n\r\n        //Instancie le state pour le graphique\r\n        this.state = {\r\n            nodes: tableauNodes,\r\n            edges: tableauEdges,\r\n        }\r\n    }\r\n\r\n    /*\r\n    Auteur : Bastien Boulanger\r\n    Paramettres\r\n        width : la largeur du labyrinthe\r\n        height : la hauteur du labyrinthe\r\n        tableauNodes : le tableau avec toutes les nodes\r\n    Description : Démare le processus de création des murs, il divise le tableau en 2 (de haut en bas) et indique ou la méthode creerMursGaucheDroite devras commencer\r\n    Valeur de retour : Aucune\r\n    */\r\n    creerMurs(width, height, tableauNodes) {\r\n        var tabIdNodesTemp = [];\r\n        var cheminTemp = 0;\r\n\r\n        //Insitancie les murs de haut en bas\r\n        for (var i = 0; i < height; i++) {\r\n            tableauNodes.forEach(node => {\r\n                if (node.id === (width * i) + Math.round(width / 2 - .5)) {\r\n                    node.color = \"#6D6D6D\";\r\n                    tabIdNodesTemp.push(node.id);\r\n                }\r\n            });\r\n        }\r\n\r\n        //Creer le trou dans le mur qui est néscéssaire pour permettre que le labyrinthe soi finissable\r\n        cheminTemp = Math.floor(Math.random() * (tabIdNodesTemp.length - 1));\r\n        while (cheminTemp === Math.round(tabIdNodesTemp.length / 2) - 1) {\r\n            cheminTemp = Math.floor(Math.random() * (tabIdNodesTemp.length - 1));\r\n        }\r\n        tableauNodes[tabIdNodesTemp[cheminTemp]].color = \"#D5C586\";\r\n        murPourFinirLabyrinthe = tabIdNodesTemp[cheminTemp];\r\n\r\n        this.creerMursGaucheDroite(tabIdNodesTemp[Math.round(tabIdNodesTemp.length / 2) - 1], Math.round(width / 2), tableauNodes, height, width);\r\n    }\r\n\r\n    /*\r\n    Auteur : Bastien Boulanger\r\n    Paramettre \r\n        depart : la valeur de l'id qui représente la moitier du murs sur lequelle l'algoritme est.\r\n        maxmin : représente la valeur du maximum de nodes que l'algoritme peu aller vers la gauche et la droite\r\n        tableauNodes : le tableau avec toutes les nodes\r\n        maxminHautBas : représente la valeur du maximum de nodes que l'algoritme peu aller vers le haut et le bas\r\n        width : la largeur du labyrinthe\r\n    Description : Cette fonction créer les murs a gauche et a droite de la node dont l'id est 'depart'. La fonction\r\n                  fait aussi les trous dans ces murs pour que le labyrinthe soit faisable.\r\n    Valeur de retour : Aucune\r\n    */\r\n    creerMursGaucheDroite(depart, maxmin, tableauNodes, maxminHautbas, width) {\r\n        // Stop l'algoritme si il est rendu trop proche d'un mur\r\n        if (maxmin > 3) {\r\n            var cheminTemp = 0;\r\n\r\n            //Instancie les murs de chaque côté du depart\r\n            tableauNodes.forEach(node => {\r\n                if (node.id > depart - maxmin + (maxmin / 6) && node.id < depart + maxmin - (maxmin / 6) - 1) {\r\n                    node.color = \"#6D6D6D\";\r\n                }\r\n            });\r\n\r\n            //Créer le trou dans le murs du coté gauche\r\n            cheminTemp = Math.floor(Math.random() * (maxmin - Math.round(maxmin / 6 - .5))) + depart - maxmin + Math.round(maxmin / 4);\r\n            while (cheminTemp === depart || cheminTemp === depart - Math.round(maxmin / 2)) {\r\n                cheminTemp = Math.floor(Math.random() * (maxmin - Math.round(maxmin / 4 - .5))) + depart - maxmin + Math.round(maxmin / 4 - .5);\r\n            }\r\n            tableauNodes[cheminTemp].color = \"#D5C586\";\r\n\r\n            //Créer le trou dans le murs du coté droit\r\n            cheminTemp = Math.floor(Math.random() * (maxmin - Math.round(maxmin / 6 - 2))) + depart - Math.round(maxmin / 4);\r\n            while (cheminTemp === depart + 1 || cheminTemp === depart + Math.round(maxmin / 2)) {\r\n                cheminTemp = Math.floor(Math.random() * (maxmin - Math.round(maxmin / 4 - 2))) + depart + Math.round(maxmin / 4);\r\n            }\r\n            tableauNodes[cheminTemp].color = \"#D5C586\";\r\n\r\n            //Appele la fonction pour faire les murs d'en haut et bas de chaque coter\r\n            this.creerMursHautBas(depart - Math.round(maxmin / 2), Math.round(maxminHautbas / 2) - 1, tableauNodes, maxmin, width);\r\n            this.creerMursHautBas(depart + Math.round(maxmin / 2), Math.round(maxminHautbas / 2) - 1, tableauNodes, maxmin, width);\r\n        }\r\n\r\n    }\r\n\r\n    /*\r\n    Auteur : Bastien Boulanger\r\n    Paramettre \r\n        depart : la valeur de l'id qui représente la moitier du murs sur lequelle l'algoritme est.\r\n        maxmin : représente la valeur du maximum de nodes que l'algoritme peu aller vers le haut et le bas\r\n        tableauNodes : le tableau avec toutes les nodes\r\n        maxminGaucheDroite : représente la valeur du maximum de nodes que l'algoritme peu aller vers la gauche et la droite\r\n        width : la largeur du labyrinthe\r\n    Description : Cette fonction créer les murs du haut et du bas de la node dont l'id est 'depart'. La fonction\r\n                  fait aussi les trous dans ces murs pour que le labyrinthe soit faisable.\r\n    Valeur de retour : Aucune\r\n    */\r\n    creerMursHautBas(depart, maxmin, tableauNodes, maxminGaucheDroite, width) {\r\n        // Stop l'algoritme si il est rendu trop proche d'un mur\r\n        if (maxmin > 3) {\r\n            var tabIdNodesPlus = [];\r\n            var tabIdNodesMoins = [];\r\n            var cheminTemp = 0;\r\n\r\n            //Instancie les murs en haut et en bas de depart (on commence par les mettre dans un tableau pour les appelés apres)\r\n            for (var i = 1; i <= maxmin; i++) {\r\n                tabIdNodesPlus.push(depart - i * width);\r\n                tabIdNodesMoins.push(depart + i * width);\r\n            }\r\n            //ici on appele toutes les nodes qui étais en haut ou en bas de depart et on change leurs couleurs\r\n            tableauNodes.forEach(node => {\r\n                for (var i = 0; i < tabIdNodesMoins.length; i++) {\r\n                    if (node.id === depart || node.id === tabIdNodesMoins[i] || node.id === tabIdNodesPlus[i]) {\r\n                        node.color = \"#6D6D6D\";\r\n                    }\r\n                }\r\n            });\r\n\r\n            //Créer le trou dans le murs en bas\r\n            cheminTemp = Math.floor(Math.random() * (tabIdNodesMoins.length - 2));\r\n            while (cheminTemp === Math.round(tabIdNodesMoins.length / 2) || tabIdNodesMoins[cheminTemp] === depart) {\r\n                cheminTemp = Math.floor(Math.random() * (tabIdNodesMoins.length - 2));\r\n            }\r\n            tableauNodes[tabIdNodesMoins[cheminTemp]].color = \"#D5C586\";\r\n\r\n            //Créer le trou dans le murs en haut\r\n            cheminTemp = Math.floor(Math.random() * (tabIdNodesPlus.length - 1));\r\n            while (cheminTemp === Math.round(tabIdNodesPlus.length / 2) || tabIdNodesPlus[cheminTemp] === depart) {\r\n                cheminTemp = Math.floor(Math.random() * (tabIdNodesPlus.length - 1));\r\n            }\r\n            tableauNodes[tabIdNodesPlus[cheminTemp]].color = \"#D5C586\";\r\n\r\n            //Appele la fonction pour faire les murs a gauche et a droite de chaque direction (haut et bas)\r\n            this.creerMursGaucheDroite(tabIdNodesPlus[Math.round(tabIdNodesMoins.length / 2)], Math.round(maxminGaucheDroite / 2), tableauNodes, maxmin, width);\r\n            this.creerMursGaucheDroite(tabIdNodesMoins[Math.round(tabIdNodesPlus.length / 2)], Math.round(maxminGaucheDroite / 2), tableauNodes, maxmin, width);\r\n        }\r\n    }\r\n\r\n    render() {\r\n        var retour = [];\r\n        var graph = {\r\n            edges: this.state.edges,\r\n            nodes: this.state.nodes,\r\n        }\r\n        var options = {\r\n            layout: {\r\n                hierarchical: false,\r\n            },\r\n            nodes: {\r\n                shape: 'square',\r\n                size: 50\r\n            },\r\n            interaction: {\r\n                dragNodes: false,\r\n                zoomView: false,\r\n            },\r\n            physics: {\r\n                enabled: false,\r\n            },\r\n            edges: {\r\n                color: \"#fff\",\r\n                width: 81,\r\n                arrows: {\r\n                    to: false,\r\n                },\r\n            }\r\n        };\r\n        retour.push(<Graph graph={graph} options={options} style={{ height: \"1000px\", width: \"100%\" }} />);\r\n        return retour;\r\n    }\r\n}\r\nexport default AffichageGraph;","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport AffichageGraph from './component/AffichageGraph';\nReactDOM.render(\n  <React.StrictMode>\n    <AffichageGraph />\n  </React.StrictMode>,\n  document.getElementById('root')\n); \n"],"sourceRoot":""}